package com.creatifcubed.clavier;

import scala.math;
import scala.util.Random;
import scala.math.BigInt;
import java.math.BigInteger;

object Scalability {
	/*
	 * - mapHashToId is an (attempt at an efficent) implementation of a deterministic mapping with versions
	 *   (e.g. number of nodes increase, mod old user ids but the old number, mod new user ides by the new number)
	 * - genHash creates hashes with the version to be decoded with (should match the mapping function)
	 * - genUniqueIdDistributed uses the encoding technique twice to show how unique ids can be generated by multiple nodes.
	 *   These ids can be mapped to operating-nodes.
	 *   Both operations are scalable; generating-nodes can be added,
	 *   and all the new nodes can generate new ids without affecting the others
	 *   (simply by encoding a higher node number).
	 *   The hash mapping/encoding method above is used to map old ids to the old set of nodes,
	 *   and new ids to the new (presumably larger) set of nodes
	 * - the key parts of the mapping scheme are:
	 *   a) being able to statically chop off a tag
	 *   b) jumping to a function based on the tag (as an offset)
	 * - note: I know the shift and mask operations aren't necessarily efficient here, but the idea is the same.
	     For example, the id itself could be a string, and the tags could be prefix ascii hexadecimal characters
		 which could be converted to integer values.
	 */

	def encodeTagIntoHash(x: BigInt, t: Int, bits: Int): BigInt = {
		return (x << bits) + t;
	}

	def decodeTagFromHash(x: BigInt, bits: Int): (BigInt, Int) = {
		return (x >> bits, (x & ((1 << bits) - 1)).intValue);
	}

	val MapHashToIdMaskBits = 16;
	val mapHashToId: (BigInt) => BigInt = {
		val hashFunctions: Array[(BigInt) => BigInt] = Array[(BigInt) => BigInt](Scalability.mapHashToIdV1, Scalability.mapHashToIdV2, Scalability.mapHashToIdV3);
		(x: BigInt) => {
			val (hash, version) = decodeTagFromHash(x, MapHashToIdMaskBits);
			hashFunctions(version)(hash);
		};
	}

	def mapHashToIdV1(x: BigInt): BigInt = {
		return x % 128;
	}

	def mapHashToIdV2(x: BigInt): BigInt = {
		return x % 256;
	}

	def mapHashToIdV3(x: BigInt): BigInt = {
		return x % 512;
	}

	def genHash(version: Int): BigInt = {
		val x: Int = Random.nextInt((2 << 30) - 1);
		return encodeTagIntoHash(makeBigint(x), version, MapHashToIdMaskBits);
	}

	val EncodeNodeBits = 32;
	val HASH_VERSION = 0;
	val genUniqueIdDistributed: () => BigInt = {
		val nodes: Array[() => BigInt] = new Array[() => BigInt](1);
		for (i <- 0 until nodes.length) {
			nodes(i) = genNode(i);
		}
		() => { encodeTagIntoHash(nodes(Random.nextInt(nodes.length))(), HASH_VERSION, MapHashToIdMaskBits); };
	}

	def genNode(id: Int): () => BigInt = {
		(() => {
			var x = 0;
			() => {
				x += 1;
				encodeTagIntoHash(x, id, EncodeNodeBits);
			};
		})();
	}

	def makeBigint(x: Int): BigInt = {
		return new BigInt(BigInteger.valueOf(x));
	}

	def main(args: Array[String]): Unit = {
		println(mapHashToId(encodeTagIntoHash(makeBigint(100), 0, MapHashToIdMaskBits)));
		println(mapHashToId(encodeTagIntoHash(200, 0, MapHashToIdMaskBits)));
		println(mapHashToId(encodeTagIntoHash(200, 1, MapHashToIdMaskBits)));
		println(mapHashToId(encodeTagIntoHash(400, 1, MapHashToIdMaskBits)));
		println(mapHashToId(encodeTagIntoHash(400, 2, MapHashToIdMaskBits)));
		println(mapHashToId(encodeTagIntoHash(800, 2, MapHashToIdMaskBits)));
		for (i <- 0 until 16) {
			((x: BigInt) => { print(x); print(" -> "); println(mapHashToId(x)); })(genHash(i % 3));
		}
		for (i <- 0 until 16) {
			val (x, _) = decodeTagFromHash(decodeTagFromHash(genUniqueIdDistributed(), MapHashToIdMaskBits)._1, EncodeNodeBits);
			println(x);
		}
	}
}
